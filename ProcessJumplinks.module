<?php

/**
 * ProcessJumplinks - a ProcessWire Module by Mike Anthony
 * Manage permanent and temporary redirects. Supports wildcards.
 *
 * Requires ProcessWire 2.5.3
 *
 * Copyright (c) 2015, Mike Anthony. All Rights Reserved.
 * Licence: MIT License - http://mikeanthony.mit-license.org/
 *
 * https://github.com/mike-anthony/ProcessJumplinks/wiki
 *
 */

require_once __DIR__ . '/Classes/Blueprint.php';
require_once __DIR__ . '/Classes/ParseCSV.php';

class ProcessJumplinks extends Process implements ConfigurableModule {

	/** Schema version for this release */
	const schemaVersion = 1;

	/** Module docs link */
	const HREF = 'https://github.com/mike-anthony/ProcessJumplinks/wiki';

	/** Config names */
	const _schemaVersion = "schemaVersion";
	const enhancedWildcardCleaning = "enhancedWildcardCleaning";
	const legacyDomain = "legacyDomain";
	const moduleDebug = "moduleDebug";
	const redirectsImported = "redirectsImported";
	const statusCodes = "statusCodes";
	const wildcardCleaning = "wildcardCleaning";

	/**
	 * Determine if the text/plain header is set
	 * @var boolean
	 */
	protected $headerSet = false;

	/**
	 * Object (Array) that holds SQL statements
	 * @var stClass
	 */
	protected $sql;

	/**
	 * Hold module information
	 * @var array
	 */
	protected $moduleInfo;

	/**
	 * The base table name
	 * @rfc Should we make this constant?
	 * @var string
	 */
	protected $tableName = 'process_jumplinks';

	/**
	 * Paths to forms
	 * @var string
	 */
	protected $entityFormPath = 'entity/';
	protected $mappingCollectionFormPath = 'mappingcollection/';
	protected $importPath = 'import/';

	/**
	 * Set the wildcard types.
	 * A wildcard type is the second fragment of a wildcard/
	 * Ex: {name:type}
	 * @var array
	 */
	protected $wildcards = array(
		'all' => '.*',
		'alpha' => '[a-z]+',
		'alphanum' => '\w+',
		'any' => '[\w.-_%\=\s]+',
		'ext' => 'aspx|asp|cfm|cgi|fcgi|dll|html|htm|shtml|shtm|jhtml|phtml|xhtm|xhtml|rbml|jspx|jsp|phps|php4|php',
		'num' => '\d+',
		'segment' => '[\w_-]+',
		'segments' => '[\w/_-]+',
	);

	/**
	 * Set smart wildcards.
	 * These are like shortcuts for declaring wildcards.
	 * See the docs for more info.
	 * @var array
	 */
	protected $smartWildcards = array(
		'all' => 'all',
		'ext' => 'ext',
		'name|title|page|post|user|model|entry' => 'segment',
		'path|segments' => 'segments',
		'year|month|day|id|num' => 'num',
	);

	/**
	 * Get the default configuration details
	 * @return array
	 */
	protected static function getConfigDefaultsArray() {

		return array(
			self::_schemaVersion => self::schemaVersion,
			self::enhancedWildcardCleaning => false,
			self::legacyDomain => '',
			self::moduleDebug => false,
			self::redirectsImported => false,
			self::statusCodes => '200 301 302',
			self::wildcardCleaning => 'fullClean',
		);
	}

	/**
	 * Get config input fiels
	 * @param  array  $data
	 * @return InputfieldWrapper
	 */
	public static function getModuleConfigInputfields(array $data) {
		// Inject assets
		wire('config')->scripts->add(wire('config')->urls->ProcessJumplinks . 'Assets/ProcessJumplinks.min.js');
		wire('config')->styles->add(wire('config')->urls->ProcessJumplinks . 'Assets/ProcessJumplinks.css');
		// Include WireTabs
		wire('modules')->get('JqueryWireTabs');

		// Add JS config data
		wire('config')->js('pjModuleAdmin', true);
		wire('config')->js('pjOldRedirectsInstalled', wire('modules')->isInstalled('ProcessRedirects'));

		// Start inputfields
		$inputfields = new InputfieldWrapper();
		$data = array_merge(self::getConfigDefaultsArray(), $data);

		// Wildcard Cleaning Fieldset
		$fieldset = self::buildInputField('InputfieldFieldset', array(
			'label' => __('Wildcard Cleaning'),
			'collapsed' => Inputfield::collapsedNever,
		));

		// Wildcard Cleaning
		$fieldset->add(self::buildInputField('InputfieldRadios', array(
			'name+id' => self::wildcardCleaning,
			'description' => __("When set to 'Full Clean', each wildcard in a Destination Path will be automatically cleaned, or 'slugged', so that it is lower-case, and uses hyphens as word separators."),
			'notes' => sprintf(__("**Note:** It's highly recommended to keep this set to 'Full Clean', unless you have a module installed that uses different path formats (such as TitleCase with underscores or hyphens). [Learn more about Wildcard Cleaning](%s/Configuration#wildcard-cleaning)"), self::HREF),
			'options' => array(
				'fullClean' => __('Full Clean (default, recommended)'),
				'semiClean' => __("Clean, but don't change case"),
				'noClean' => __("Don't clean at all (not recommended)"),
			),
			'columnWidth' => 50,
			'collapsed' => Inputfield::collapsedNever,
			'skipLabel' => Inputfield::skipLabelHeader,
			'value' => $data[self::wildcardCleaning],
		)));

		// Enhanced Wildcard Cleaning
		$fieldset->add(self::buildInputField('InputfieldCheckbox', array(
			'name+id' => self::enhancedWildcardCleaning,
			'label' => __('Enhanced Wildcard Cleaning'),
			'description' => __("When enabled, wildcard cleaning goes a step further by means of breaking and hyphenating TitleCase wildcards, as well as those that contain abbreviations (ex: NASALaunch). Examples below."),
			'label2' => __('Use Enhanced Wildcard Cleaning'),
			'notes' => __("**Examples:** 'EnvironmentStudy' would become 'environment-study' and 'NASALaunch' would become 'nasa-launch'."),
			'columnWidth' => 50,
			'collapsed' => Inputfield::collapsedNever,
			'autocheck' => true,
			'value' => $data[self::enhancedWildcardCleaning],
		)));

		$inputfields->add($fieldset);

		// Legacy Domain Fieldset
		$fieldset = self::buildInputField('InputfieldFieldset', array(
			'label' => __('Legacy Domain'),
			'collapsed' => Inputfield::collapsedYes,
		));

		// Legacy Domain Name
		$fieldset->add(self::buildInputField('InputfieldText', array(
			'name+id' => self::legacyDomain,
			'columnWidth' => 50,
			'description' => __('Attempt any requested, unresolved Source paths on a legacy domain/URL.'),
			'notes' => __("Enter a full, valid domain/URL. **Source Path won't be cleaned upon redirect**."),
			'placeholder' => __('Examples: "http://legacy.domain.com/" or "http://domain.com/old/"'),
			'collapsed' => Inputfield::collapsedNever,
			'skipLabel' => Inputfield::skipLabelHeader,
			'spellcheck' => 'false',
			'value' => $data[self::legacyDomain],
		)));

		// Legacy Domain Status Codes
		$fieldset->add(self::buildInputField('InputfieldText', array(
			'name+id' => self::statusCodes,
			'columnWidth' => 50,
			'description' => __('Only redirect if a request to it yields one of these HTTP status codes:'),
			'notes' => __("Separate each code with a space. **[Use Default](#resetLegacyStatusCodes)**"),
			'collapsed' => Inputfield::collapsedNever,
			'skipLabel' => Inputfield::skipLabelHeader,
			'spellcheck' => 'false',
			'value' => $data[self::statusCodes],
		)));

		$inputfields->add($fieldset);

		// Debug Mode
		$inputfields->add(self::buildInputField('InputfieldCheckbox', array(
			'name+id' => self::moduleDebug,
			'label' => __('Debug Mode'),
			'description' => __("If you run into any problems with your jumplinks, you can turn on debug mode. Once turned on, you'll be shown a scan log when a 404 Page Not Found is hit. That will give you an indication of what may be going wrong. If it doesn't, and you can't figure it out, then paste your log into the support thread on the forums."),
			'label2' => __('Turn debug mode on'),
			'notes' => __("**Notes:** Hits won't be affected when debug mode is turned on. Also, only those that have permission to manage jumplinks will be shown the debug logs."),
			'collapsed' => Inputfield::collapsedBlank,
			'autocheck' => true,
			'value' => $data[self::moduleDebug],
		)));

		return $inputfields;
	}

	/**
	 * Inject assets (used as assets are automatically inserted when
	 * using the same name as the module, but the get thrown in before
	 * JS dependencies. WireTabs also gets thrown in.)
	 * @return [type] [description]
	 */
	protected function injectAssets() {

		// Inject script and style
		$this->config->scripts->add($this->config->urls->ProcessJumplinks . 'Assets/ProcessJumplinks.min.js');
		$this->config->styles->add($this->config->urls->ProcessJumplinks . 'Assets/ProcessJumplinks.css');
		// Include WireTabs
		$this->modules->get('JqueryWireTabs');
	}

	/**
	 * Class constructor
	 * Init moduleInfo, sql
	 */
	public function __construct() {

		$this->setArray(self::getConfigDefaultsArray());
		$this->moduleInfo = wire('modules')->getModuleInfo($this, array('verbose' => true));
		$this->sql = (object) array(
			'entitySelectAll' =>
				"SELECT * FROM {$this->tableName} ORDER BY source",
			'entitySelectSingle' =>
				"SELECT * FROM {$this->tableName} WHERE id = :id",
			'entityDropById' =>
				"DELETE FROM {$this->tableName} WHERE id = :id",
			'entityInsert' =>
				"INSERT INTO {$this->tableName} SET source = :source, destination = :destination, hits = :hits, date_start = :date_start, date_end = :date_end, user_created = :user_created, user_updated = :user_updated, created_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP ON DUPLICATE KEY UPDATE id = id",
			'entityUpdate' =>
				"UPDATE {$this->tableName} SET source = :source, destination = :destination, date_start = :date_start, date_end = :date_end, user_updated = :user_updated, updated_at = CURRENT_TIMESTAMP WHERE id = :id",
			'entityUpdateHits' =>
				"UPDATE {$this->tableName} SET hits = :hits WHERE id = :id",
			'mappingCollectionsSelectAll' =>
				"SELECT * FROM {$this->tableName}_mc ORDER BY collection_name",
			'mappingCollectionsSelectSingle' =>
				"SELECT * FROM {$this->tableName}_mc WHERE id = :id",
			'mappingCollectionsSelectSingleFromName' =>
				"SELECT * FROM {$this->tableName}_mc WHERE collection_name = :collection",
			'mappingCollectionsDropById' =>
				"DELETE FROM {$this->tableName}_mc WHERE id = :id",
			'mappingCollectionsInsert' =>
				"INSERT INTO {$this->tableName}_mc SET collection_name = :collection, collection_mappings = :mappings, user_created = :user_created, user_updated = :user_updated, created_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP ON DUPLICATE KEY UPDATE id = id",
			'mappingCollectionsUpdate' =>
				"UPDATE {$this->tableName}_mc SET collection_name = :collection, collection_mappings = :mappings, user_updated = :user_updated WHERE id = :id",
		);
	}

	/**
	 * Module initialisation
	 * @hook ProcessPageView::pageNotFound to scanAndRedirect
	 */
	public function init() {

		parent::init();

		// Set the admin page URL for JS
		$this->config->js("pjAdminPageUrl", $this->pages->get('name=jumplinks')->url);

		// Make sure schemas are up to date
		if ($this->schemaVersion < self::schemaVersion) {
			$this->updateDatabaseSchemas();
		}

		// Set the request (URI), and trim off the leading slash,
		// as we won't be needing it for comparison.
		$this->request = ltrim($_SERVER['REQUEST_URI'], '/');

		// If a request is made to the index.php file, with a slash,
		// then redirect to root (mod_rewrite is a PW requirement)
		if ($this->request === 'index.php/' || $this->request === 'index.php') {
			$this->session->redirect($this->config->urls->root);
		}

		// Magic ahead: Replace index.php with a dummy do we can scan such requests.
		// But first, redirect requests to index.php/ so we don't have any legacy domain false positives,
		// such as remote 301s used to trim trailing slashes.
		$indexExpression = "~^index.php(\?|\/)~";
		if (preg_match($indexExpression, $this->request)) {
			$this->session->redirect(preg_replace(
				$indexExpression,
				"{$this->config->urls->root}index.php.pwpj\\1",
				$this->request
			));
		}

		// Hook prior to the pageNotFound event ...
		$this->addHookBefore('ProcessPageView::pageNotFound', $this, 'scanAndRedirect', array('priority' => 10));
	}

	/**
	 * Update database schema
	 * This method applies incremental updates until latest schema version is
	 * reached, while also keeping schemaVersion config setting up to date.
	 * @state    Will be populated on first schema change
	 */
	private function updateDatabaseSchemas() {}

	/**
	 * Generate help link (contextual)
	 * @param  string $uri
	 * @return string
	 */
	protected function helpLinks($uri = '', $justTheLink = false) {

		if (!empty($uri)) {
			$uri = "/{$uri}";
		}

		return ($justTheLink)
			? $this->moduleInfo['href'] . $uri
			: "<div class=\"pjHelpLink\"><a class=\"paypal\" target=\"_blank\" href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=L8F6FFYK6ENBQ\">Donate via PayPal</a><a target=\"_blank\" href=\"https://processwire.com/talk/topic/8697-module-jumplinks/\">Need Help?</a><a target=\"_blank\" href=\"{$this->moduleInfo['href']}{$uri}\">Documentation</a></div>";
	}

	/**
	 * Create a blueprint from file and give it some variables.
	 * @caller multiple
	 * @param  string $name
	 * @param  array  $data
	 * @return string
	 */
	protected function blueprint($name, $data = array()) {

		$blueprint = new Blueprint($name);

		$data = array_filter($data);

		if (empty($data)) {
			$data = array('table-name' => $this->tableName);
		}

		$blueprint->hydrate($data);

		return (string) $blueprint->build();
	}

	/**
	 * Compile destination URL, keeping page refs, HTTPS, and subdirectories considered.
	 * @caller multiple
	 * @param  string $destination
	 * @param  bool   $renderForOutput
	 * @param  bool   $http
	 * @return string
	 */
	protected function compileDestinationUrl($destination, $renderForOutput = false, $http = true) {

		$pageIdentifier = 'page:';

		// Check if we're using a page identifier
		if (substr($destination, 0, 5) !== $pageIdentifier) {
			// Check to see if we're working with an absolute URL
			// and if we're currently using HTTPS
			$hasScheme = (bool) parse_url($destination, PHP_URL_SCHEME);
			$https = ($this->config->https) ? 's' : '';

			// If URL is absolute, then skip the prefix, otherwise build it
			$prefix = ($hasScheme) ? '' : "http{$https}://{$this->config->httpHost}/";

			// If we're rendering for backend output, truncate and return the destination.
			// Otherwise, return the full destination.
			return ($renderForOutput)
				? $this->truncate($destination, 45)
				: $prefix . $destination;
		}

		// If we're using a page identifier, fetch it
		$pageId = str_replace($pageIdentifier, '', $destination);
		$page = $this->pages->get((int) $pageId);

		// If it's a valid page, then get its URL
		if ($page->id) {
			$pagePath = $page->get($http ? "httpUrl" : "path");

			// If we're rendering for output, make it pretty.
			$destination = ($renderForOutput)
				? "<abbr title=\"{$pagePath}\">{$page->get('headline|title|name')}<abbr>"
				: $pagePath;
		}

		return $destination;
	}

	/**
	 * Fetch the URI to the module's config page
	 * @caller multiple
	 * @return string
	 */
	protected function getModuleConfigUri() {

		return "{$this->config->urls->admin}module/edit?name={$this->moduleInfo['name']}";
		// ^ Better way to get this URI?
	}

	/**
	 * Clean a passed wildcard value
	 * @caller scanAndRedirect
	 * @param  string $input
	 * @param  bool   $noLower
	 * @return string
	 */
	public function cleanWildcard($input, $noLower = false) {

		if ($this->{self::enhancedWildcardCleaning}) {
			// Courtesy @sln on StackOverflow
			$input = preg_replace_callback("~([A-Z])([A-Z]+)(?=[A-Z]|\b)~", function ($captures) {
				return $captures[1] . strtolower($captures[2]);
			}, $input);
			$input = preg_replace("~(?<=\\w)(?=[A-Z])~", "-\\1\\2", $input);
		}

		$input = preg_replace("~%u([a-f\d]{3,4})~i", "&#x\\1;", urldecode($input));
		$input = preg_replace("~[^\\pL\d\/]+~u", '-', $input);
		$input = iconv('utf-8', 'us-ascii//TRANSLIT', $input);

		if ($this->{self::enhancedWildcardCleaning}) {
			$input = preg_replace("~(\d)([a-z])~i", "\\1-\\2", preg_replace("~([a-z])(\d)~i", "\\1-\\2", $input));
		}

		$input = trim($input, '-');
		$input = preg_replace('~[^-\w\/]+~', '', $input);
		if (!$noLower) {
			$input = strtolower($input);
		}

		return (empty($input)) ? '' : $input;
	}

	/**
	 * Truncate string, and append ellipses with tooltip
	 * @caller multiple
	 * @param  string $string
	 * @param  int    $length
	 * @return string
	 */
	protected function truncate($string, $length = 55) {

		return (strlen($string) > $length)
			? substr($string, 0, $length) . " <span class=\"ellipses\" title=\"{$string}\">...</span>"
			: $string;
	}

	/**
	 * Given a fieldtype, create, populate, and return an Inputfield
	 * @param  string $fieldNameId
	 * @param  array  $meta
	 * @return Inputfield
	 */
	protected static function buildInputField($fieldNameId, $meta) {

		$field = wire('modules')->get($fieldNameId);

		foreach ($meta as $metaNames => $metaInfo) {
			$metaNames = explode('+', $metaNames);
			foreach ($metaNames as $metaName) {
				$field->$metaName = $metaInfo;
			}
		}

		return $field;
	}

	/**
	 * Given a an Inputfield, add props and return
	 * @param  string $field
	 * @param  array  $meta
	 * @return Inputfield
	 */
	protected function populateInputField($field, $meta) {

		foreach ($meta as $metaNames => $metaInfo) {
			$metaNames = explode('+', $metaNames);
			foreach ($metaNames as $metaName) {
				$field->$metaName = $metaInfo;
			}
		}

		return $field;
	}

	/**
	 * Get response code of remote request
	 * @caller scanAndRedirect
	 * @param  $request
	 * @return string
	 */
	protected function getResponseCode($request) {

		stream_context_set_default(array(
			'http' => array(
				'method' => 'HEAD',
			),
		));

		$response = get_headers($request);

		return substr($response[0], 9, 3);
	}

	/**
	 * Determine if the current user has debug rights.
	 * Must have relevant permission, and debug mode must be turned on.
	 * @return bool
	 */
	protected function userHasDebugRights() {

		return ($this->{self::moduleDebug} && $this->user->hasPermission('jumplinks-admin'));
	}

	/**
	 * Log something. Will set plain text header if not already set.
	 * @caller scanAndRedirect
	 * @param  string $message
	 * @param  bool   $indent
	 * @param  bool   $break
	 * @param  bool   $die
	 */
	protected function log($message, $indent = false, $break = false, $die = false) {

		if ($this->userHasDebugRights()) {
			if (!$this->headerSet) {
				header("Content-Type: text/plain");
				$this->headerSet = true;
			}

			$indent = ($indent) ? "- " : '';
			$break = ($break) ? "\n" : '';

			print str_replace('.pwpj', '', "{$indent}{$message}\n{$break}");

			if ($die) {
				die();
			}
		}
	}

	/**
	 * The fun part.
	 * @caller Hook: ProcessPageView::pageNotFound
	 */
	protected function scanAndRedirect() {

		$jumplinks = $this->db->query($this->sql->entitySelectAll);

		if ($jumplinks->num_rows === 0) {
			return false;
		}

		$this->log("Page not found; scanning for jumplinks...");

		$request = $this->request;
		$requestedUrlFirstPart = "http" . ((@$_SERVER['HTTPS'] == 'on') ? "s" : "") . "://{$_SERVER['HTTP_HOST']}";

		// Do some logging
		$this->log('Checked at: ' . date('r'), true);
		$this->log("Requested URL: {$requestedUrlFirstPart}/{$request}", true);
		$this->log("PW Version: {$this->config->version}\n\n== START ==", true, true);

		$rootUrl = $this->config->urls->root;

		if ($rootUrl !== '/') {
			$request = substr($request, strlen($rootUrl) - 1);
		}

		// Get the available wildcards, prepare for pattern match
		$availableWildcards = '';
		foreach ($this->wildcards as $wildcard => $expression) {
			$availableWildcards .= "$wildcard|";
		}
		$availableWildcards = rtrim($availableWildcards, '|');

		// Assign the wildcard pattern check
		$pattern = '~\{!?([a-z]+):(' . $availableWildcards . ')\}~';

		// Begin the loop
		while ($jumplink = $jumplinks->fetch_object()) {
			$starts = strtotime($jumplink->date_start);
			$ends = strtotime($jumplink->date_end);

			// Timed Activation:
			// If it ends, but doesn't start, then make it start now
			if ($ends && !$starts) {
				$starts = time();
			}

			// If it starts (which it will always do), but doesn't end,
			// then set a dummy timestamp that is always in the future.
			if ($starts && !$ends) {
				$ends = time() + (60 * 60);
				$message = '(has no ending, using dummy timestamp)';
			} else {
				$message = '';
			}

			$this->log("[Checking jumplink #{$jumplink->id}]");

			// Log the activation periods for debugging
			if ($starts || $ends) {
				$this->log(sprintf("Timed Activation:             %s to %s {$message}", date('r', $starts), date('r', $ends)), true);
			}

			$this->log("Original Source Path:         {$jumplink->source}", true);

			// Prepare the Source Path for matching:
			// First, escape ? & :, and rename index.php so we can make use of such requests.
			// Then, convert '[character]' to 'character?' for matching.
			$source = preg_replace('~\[([a-z0-9\/])\]~i', "\\1?", str_replace(
				array('?', '&', ':', '+', 'index.php'),
				array('\?', '\&', '\:', '+', 'index.php.pwpj'),
				$jumplink->source));

			// Reverse ? escaping for wildcards
			$source = preg_replace("~\{([a-z]+)\\\:([a-z]+)\}~i", "{\\1:\\2}", $source);

			// Compile the destination URL
			$destination = $this->compileDestinationUrl($jumplink->destination);

			if ($source !== $jumplink->source) {
				$this->log("Escaped Source Path:          {$source}", true);
			}

			// Setup capture prevention
			$nonCaptureMatcher = "~<(.*?)>~";
			if (preg_match($nonCaptureMatcher, $source)) {
				$source = preg_replace($nonCaptureMatcher, "(?:\\1)", $source);
			}

			// Prepare Smart Wildcards - replace them with their equivalent standard ones.
			$hasSmartWildcards = false;
			foreach ($this->smartWildcards as $wildcard => $wildcardType) {
				$smartWildcardMatcher = "~\{($wildcard)\}~i";
				if (preg_match($smartWildcardMatcher, $source)) {
					$source = preg_replace($smartWildcardMatcher, "{\\1:{$wildcardType}}", $source);
					$hasSmartWildcards = true;
				}
			}

			$computedReplacements = array();

			// Convert wildcards into expressions for replacement
			$computedWildcards = preg_replace_callback($pattern, function ($captures) use (&$computedReplacements) {
				$computedReplacements[] = $captures[1];
				return "({$this->wildcards[$captures[2]]})";
			}, $source);

			// Some more logging
			if ($hasSmartWildcards) {
				$this->log("After Smart Wildcards:        {$source}", true);
			}

			$this->log("Compiled Source Path:         {$computedWildcards}", true);

			// If the request matches the source currently being checked:
			if (preg_match("~^$computedWildcards$~i", $request)) {

				// For the purposes of mapping, fetch all the collections and compile them
				$collections = $this->db->query($this->sql->mappingCollectionsSelectAll);
				$compiledCollections = new StdClass();
				while ($collection = $collections->fetch_object()) {
					$collectionData = explode("\n", $collection->collection_mappings);
					$compiledCollectionData = array();
					foreach ($collectionData as $mapping) {
						$mapping = explode('=', $mapping);
						$compiledCollectionData[$mapping[0]] = $mapping[1];
					}

					$compiledCollections->{$collection->collection_name} = $compiledCollectionData;
				}

				// Iterate through each source wildcard:
				$convertedWildcards = preg_replace_callback("~$computedWildcards~i", function ($captures) use ($destination, $computedReplacements) {
					$result = $destination;

					for ($c = 1, $n = count($captures); $c < $n; ++$c) {
						$value = array_shift($computedReplacements);

						// Check for destination wildcards that don't need to be cleaned
						$paramSkipCleanCheck = "~\{!$value\}~i";
						$uncleanedCapture = $captures[$c];
						if (!preg_match($paramSkipCleanCheck, $result)) {
							$wildcardCleaning = $this->{self::wildcardCleaning};
							if ($wildcardCleaning === 'fullClean' || $wildcardCleaning === 'semiClean') {
								$captures[$c] = $this->cleanWildcard($captures[$c], ($wildcardCleaning === 'fullClean') ? false : true);
							}
						}
						$openingTag = (preg_match($paramSkipCleanCheck, $result)) ? '{!' : '{';
						$result = str_replace($openingTag . $value . '}', $captures[$c], $result);

						// In preparation for wildcard mapping,
						// Swap out any mapping wildcards with their uncleaned values
						$value = preg_quote($value);
						$result = preg_replace("~\{{$value}\|([a-z]+)\}~i", "($uncleanedCapture|\\1)", $result);
					}

					// Trim the result of trailing slashes, and
					// add one again if the Destination Path asked for it.
					$result = rtrim($result, '/');
					if (substr($destination, -1) === '/') {
						$result .= '/';
					}

					return $result;
				}, $request);

				// Perform any mappings
				$convertedWildcards = preg_replace_callback("~\(([\w-_\/]+)\|([a-z]+)\)~i", function ($mapCaptures) use ($compiledCollections) {
					if (isset($compiledCollections->{$mapCaptures[2]}[$mapCaptures[1]])) {
						// If we have a match, bring it in
						return $compiledCollections->{$mapCaptures[2]}[$mapCaptures[1]];
					} else {
						// Otherwise, fill the mapping wildcard with the original data
						return $mapCaptures[1];
					}
				}, $convertedWildcards);

				$this->log("Original Destination Path:    $jumplink->destination", true);
				$this->log("Compiled Destination Path:    $convertedWildcards", true, true);

				// Check for Timed Activation and determine if we're in the period specified
				$time = time();
				$activated = ($starts || $ends)
					? ($time >= $starts && $time <= $ends)
					: true;

				// If we're not debugging, and we're Time-activated, then do the redirect
				if (!$this->userHasDebugRights() && $activated) {
					$hitsPlusOne = $jumplink->hits + 1;
					$this->database->prepare($this->sql->entityUpdateHits)->execute(array(
						'hits' => $hitsPlusOne,
						'id' => $jumplink->id,
					));
					$this->session->redirect($convertedWildcards, !$activated);
				}

				// Otherwise, continue logging
				$type = ($starts) ? '302, temporary' : '301, permanent';
				$this->log("Match found! We'll do the following redirect ({$type}) when Debug Mode has been turned off:", false, true);
				$this->log("From URL:   {$requestedUrlFirstPart}/{$request}", true);
				$this->log("To URL:     {$convertedWildcards}", true);

				if (!$activated) {
					// If it ends before it starts, then show the time it starts.
					// Otherwise, show the period.
					if ($ends < $starts) {
						$this->log(sprintf("Timed:      From %s onwards", date('r', $starts)), true);
					} else {
						$this->log(sprintf("Timed:      From %s to %s", date('r', $starts), date('r', $ends)), true);
					}
				}

				// We can exit at this point.
				if ($this->userHasDebugRights()) {
					die();
				}
			}

			// If there were no available redirect definitions,
			// then inform the debugger.
			$this->log("\nNo match there...", false, true);
		}

		// Considering we don't have one available, let's check to see if the Source Path
		// exists on the Legacy Domain, if defined.

		$legacyDomain = trim($this->{self::legacyDomain});
		if (!empty($legacyDomain)) {
			// Fetch the accepted codes
			$okCodes = trim(!empty($this->{self::statusCodes}))
				? array_map('trim', explode(' ', $this->{self::statusCodes}))
				: explode(',', $this->statusCodes);

			// Prepare and do the request
			$domainRequest = $this->{self::legacyDomain} . $request;
			$status = $this->getResponseCode($domainRequest);

			// If the response has an accepted code, then 302 redirect (or log)
			if (in_array($status, $okCodes)) {
				if (!$this->userHasDebugRights()) {
					$this->session->redirect($domainRequest, false);
				}
				$this->log("Found Source Path on Legacy Domain (with status code {$status}); redirect allowed to:");
				$this->log($domainRequest, true, false, true);
			}
		}

		// If all fails, say so.
		$this->log("No matches, sorry. We'll let the 404 error page take over when Debug Mode is turned off.");
		if ($this->userHasDebugRights()) {
			die();
		}

	}

	/**
	 * Admin Page: Module Root
	 * @return string
	 */
	public function ___execute() {

		$this->injectAssets();

		$jumplinks = $this->db->query($this->sql->entitySelectAll);
		$this->setFuel('processHeadline', $this->_('Manage Jumplinks'));

		$tabContainer = new InputfieldWrapper();

		$jumplinksTab = new InputfieldWrapper();
		$jumplinksTab->attr('title', 'Jumplinks');

		$jumplinksTable = $this->modules->get('MarkupAdminDataTable');
		$jumplinksTable->setEncodeEntities(false);
		$jumplinksTable->setClass('jumplinks redirects');
		$jumplinksTable->headerRow(array($this->_('Source'), $this->_('Destination'), $this->_('Start'), $this->_('End'), $this->_('Hits')));

		$pronoun = $this->_n('it', 'one', $jumplinks->num_rows);
		if ($jumplinks->num_rows == 0) {
			$description = $this->_("You don't have any jumplinks yet.");
		} else {
			$description = $this->_n('You have one jumplink registered.', 'Your jumplinks are listed below.', $jumplinks->num_rows) . ' ' . sprintf($this->_("To edit/delete %s, simply click on its Source."), $pronoun);
		}

		$jumplinksDescriptionMarkup = $this->modules->get('InputfieldMarkup');
		$jumplinksDescriptionMarkup->value = $description;

		$jumplinksTab->append($jumplinksDescriptionMarkup);

		$hits = 0;
		while ($jumplink = $jumplinks->fetch_object()) {
			$jumplink->source = htmlentities($jumplink->source);
			$jumplink->destination = $this->compileDestinationUrl($jumplink->destination, true);
			$relativeStartTime = str_replace('Never', '', wireRelativeTimeStr($jumplink->date_start, true));
			$relativeEndTime = str_replace('Never', '', wireRelativeTimeStr($jumplink->date_end, true));

			$relativeStartTime = ($relativeStartTime === '-')
				? $relativeStartTime
				: "<abbr title=\"{$jumplink->date_start}\">{$relativeStartTime}</abbr>";
			$relativeEndTime = ($relativeEndTime === '-')
				? $relativeEndTime
				: "<abbr title=\"{$jumplink->date_end}\">{$relativeEndTime}</abbr>";

			$hits = $hits + $jumplink->hits;

			$jumplinksTable->row(array(
				$this->truncate($jumplink->source, 80) => "{$this->entityFormPath}?id={$jumplink->id}",
				$jumplink->destination,
				$relativeStartTime,
				$relativeEndTime,
				$jumplink->hits,
			));
		}

		$wordLinks = ($jumplinks->num_rows === 1) ? 'jumplink' : 'jumplinks';
		$jumplinksTable->footerRow(array("{$jumplinks->num_rows} {$wordLinks}", '', '', '', $hits));

		switch ($jumplinks->num_rows) {
			case 0:
				$registerJumplinkButtonLabel = $this->_('Register First Jumplink');
				break;
			case 1:
				$registerJumplinkButtonLabel = $this->_('Register Another Jumplink');
				break;
			default:
				$registerJumplinkButtonLabel = $this->_('Register New Jumplink');
				break;
		}

		$jumplinks->close();

		$registerJumplinkButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
			'id' => 'registerJumplink',
			'href' => $this->entityFormPath,
			'value' => $registerJumplinkButtonLabel,
			'icon' => 'plus-circle',
		))->addClass('head_button_clone');

		$moduleConfigLinkButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
			'id' => 'moduleConfigLink',
			'href' => $this->getModuleConfigUri(),
			'value' => $this->_('Configuration'),
			'icon' => 'cog',
		))->addClass('ui-priority-secondary ui-button-float-right');

		$buttons = $registerJumplinkButton->render() . $moduleConfigLinkButton->render();

		$jumplinksTableContainer = $this->modules->get('InputfieldMarkup');
		$jumplinksTableContainer->value = $jumplinksTable->render() . $buttons;

		$jumplinksTab->append($jumplinksTableContainer);

		$mappingCollectionsTab = new InputfieldWrapper();
		$mappingCollectionsTab->attr('title', 'Mapping Collections');
		$mappingCollectionsTab->id = 'mappingCollections';

		$mappingCollections = $this->db->query($this->sql->mappingCollectionsSelectAll);

		$mappingCollectionsTable = $this->modules->get('MarkupAdminDataTable');
		$mappingCollectionsTable->setEncodeEntities(false);
		$mappingCollectionsTable->setClass('jumplinks mapping-collections');
		$mappingCollectionsTable->setSortable(false);
		$mappingCollectionsTable->headerRow(array($this->_('Collection Name'), $this->_('Mappings'), $this->_('Created'), $this->_('Last Modified')));

		if ($mappingCollections->num_rows === 0) {
			$pronoun = 'one';
			$head = $this->_("You don't have any collections installed.");
		} else {
			$head = $this->_n('You have one collection installed.', 'Your collections are listed below.', $mappingCollections->num_rows);
			$pronoun = $this->_n('it', 'one', $mappingCollections->num_rows);
		}

		$description = ($mappingCollections->num_rows === 0) ? '' : sprintf($this->_("To edit/delete %s, simply click on its name."), $pronoun);

		$mappingCollectionsDescriptionMarkup = $this->modules->get('InputfieldMarkup');
		$mappingCollectionsDescriptionMarkup->value = "{$head} {$description}";

		$mappingCollectionsTab->append($mappingCollectionsDescriptionMarkup);

		while ($mappingCollection = $mappingCollections->fetch_object()) {
			$userCreated = $this->users->get($mappingCollection->user_created)->name;
			$userUpdated = $this->users->get($mappingCollection->user_updated)->name;

			$created = wireRelativeTimeStr($mappingCollection->created_at) . " by {$userCreated}";
			$updated = wireRelativeTimeStr($mappingCollection->updated_at) . " by {$userUpdated}";

			if ($mappingCollection->created_at === $mappingCollection->updated_at) {
				$updated = '';
			}

			$mappingCollectionsTable->row(array(
				$mappingCollection->collection_name => "{$this->mappingCollectionFormPath}?id={$mappingCollection->id}",
				count(explode("\n", trim($mappingCollection->collection_mappings))),
				$created,
				$updated,
			));
		}

		$installMappingCollectionButtonLabel = ($mappingCollections->num_rows === 1) ? $this->_('Install Another Mapping Collection') : $this->_('Install New Mapping Collection');

		$mappingCollections->close();

		$installMappingCollectionButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
			'id' => 'installMappingCollection',
			'href' => $this->mappingCollectionFormPath,
			'value' => $installMappingCollectionButtonLabel,
			'icon' => 'plus-circle',
		));

		$buttons = $installMappingCollectionButton->render();

		$mappingCollectionsTableContainer = $this->modules->get('InputfieldMarkup');
		$mappingCollectionsTableContainer->value = $mappingCollectionsTable->render() . $buttons;

		$mappingCollectionsTab->append($mappingCollectionsTableContainer);

		$importTab = new InputfieldWrapper();
		$importTab->attr('title', $this->_('Import'));
		$importTab->id = 'import';

		$infoContainer = $this->modules->get('InputfieldMarkup');
		if ($this->modules->isInstalled('ProcessRedirects')) {
			$infoContainer->value = $this->_('To import your jumplinks, select an option below:');
		} else {
			$infoContainer->value = $this->_('To import your jumplinks, click the button below:');
		}

		$importTab->append($infoContainer);

		$importContainer = $this->modules->get('InputfieldMarkup');

		$importFromCSVButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
			'id' => 'importFromCSV',
			'href' => "{$this->importPath}",
			'value' => $this->_('Import from CSV'),
		));

		$importContainer->value = $importFromCSVButton->render();

		if ($this->modules->isInstalled('ProcessRedirects')) {

			$importFromRedirectsButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
				'id' => 'importFromRedirects',
				'href' => "{$this->importPath}?type=redirects",
				'value' => $this->_('Import from Redirects Module') . (($this->redirectsImported) ? ' ' . $this->_("(you've already done this)") : ''),
			))->addClass('ui-priority-secondary');

			$importContainer->value .= $importFromRedirectsButton->render();

		}

		$importTab->append($importContainer);

		$tabContainer
			->append($jumplinksTab)
			->append($mappingCollectionsTab)
			->append($importTab);

		$this->config->js("pjAdmin", true);

		// We have to wrap it in a form to prevent spacing underneath
		// the tabs. This goes hand in hand with a rule in the stylesheet
		return "<form id=\"pjTabs\">{$tabContainer->render()}{$this->helpLinks()}</form>";
	}

	/**
	 * Admin Page: Add/Edit Entity (Redirect)
	 * @return string
	 */
	public function ___executeEntity() {

		$this->injectAssets();

		$this->setFuel('processHeadline', $this->_('Register New Jumplink'));

		// Get the ID if we're editing
		$editingId = (isset($this->input->get->id)) ? $this->input->get->id : 0;

		if ($editingId) {
			// Fetch the details and list vars
			$query = $this->database->prepare($this->sql->entitySelectSingle);
			$query->execute(array(
				'id' => $editingId
			));
			list($id, $sourcePath, $destinationUriUrl, $hits,
				$userCreated, $userUpdated, $dateStart, $dateEnd,
				$createdAt, $updatedAt) = $query->fetch();

			$this->setFuel('processHeadline', $this->_('Editing Jumplink'));

			// Format dates (times)
			$nullValue = '0000-00-00 00:00:00';
			$dateStart = ($dateStart !== $nullValue) ? date('Y-m-d h:m A', strtotime($dateStart)) : null;
			$dateEnd = ($dateEnd !== $nullValue) ? date('Y-m-d h:m A', strtotime($dateEnd)) : null;
		}

		// Prep the form
		$form = $this->modules->get('InputfieldForm');
		$form->id = 'pjInputForm';
		$form->method = 'POST';
		$form->action = '../commit/';

		// ID field
		$field = $this->modules->get('InputfieldHidden');
		$form->add($this->populateInputField($field, array(
			'name' => 'id',
			'value' => $editingId,
		)));

		// Source Path field
		$field = $this->modules->get('InputfieldText');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'sourcePath',
			'label' => $this->_('Source'),
			'description' => $this->_("Enter a path that's relative to the root of this installation, without the leading slash."),
			'notes' => sprintf($this->_("**Examples:** page.html, [{page:segment}](%1\$s/Wildcards).html, page.php?name={page:segment}, [page.php?id={id}](%1\$s/Mapping-Collections)"), $this->moduleInfo['href']),
			'required' => 1,
			'collapsed' => Inputfield::collapsedNever,
			'value' => isset($sourcePath) ? $sourcePath : '',
		)));

		// Destination fields
		$destinationPageField = $this->modules->get('InputfieldPageListSelect');
		$destinationPathField = $this->modules->get('InputfieldURL');

		// Check if the current destination is a page
		if (isset($destinationUriUrl) && $page = $this->pages->get((int) str_replace('page:', '', $destinationUriUrl))) {
			$isPage = (bool) $page->id;
			if ($isPage) {
				$destinationPageField->value = $page->id;
				$destinationPathField->collapsed = Inputfield::collapsedYes;
			} else {
				$destinationPageField->collapsed = Inputfield::collapsedYes;
				$destinationPathField->collapsed = Inputfield::collapsedBlank;
			}
		} else {
			$destinationPathField->collapsed = Inputfield::collapsedBlank;
		}

		$form->add($this->populateInputField($destinationPageField, array(
			'name+id' => 'destinationPage',
			'label' => $this->_('Select a Page'),
			'notes' => $this->_("If you leave this out, be sure to enter a valid path below.\n**Note:** If you need to see the details of a page in another language, you'll need to [switch to that language first](../../../profile)."),
			'parent_id' => 0,
			'startLabel' => $this->_('Select Page'),
		)));

		// Destination Path field
		$form->add($this->populateInputField($destinationPathField, array(
			'name+id' => 'destinationUriUrl',
			'label' => $this->_('or enter a URI/URL'),
			'description' => $this->_('Enter a URI relative to the root of this installation, without the leading slash, or an absolute URL.'),
			'notes' => sprintf($this->_("**Examples:** path/, {path}/, http://domain.com/{path}, [product/{id|products}](%s/Mapping-Collections) .\n**Note:** If you select a page from the Page Selector above, its identifier will be added here."), $this->moduleInfo['href']),
			'required' => 1,
			'value' => isset($destinationUriUrl) ? $destinationUriUrl : '',
		)));

		// Timed Activation fieldset
		$fieldSet = $this->modules->get('InputfieldFieldset');
		$fieldSet->label = 'Timed Activation';
		$fieldSet->collapsed = Inputfield::collapsedYes;
		$fieldSet->description = $this->_("If you'd like this jumplink to only function during a specific time-range, then select the start and end dates and times below.");
		$fieldSet->notes = $this->_("You don't have to specify both. If you only specify a start time, you're simply delaying activation. If you only specify an end time, then you're simply telling it when to stop.\nIf an End Date/Time is specified, a temporary redirect will be made (302 status code, as opposed to 301).");

		$datetimeFieldDefaults = array(
			'datepicker' => 1,
			'timeInputFormat' => 'h:m A',
			'yearRange' => '-0:+100',
			'collapsed' => Inputfield::collapsedNever,
			'columnWidth' => 50,
		);

		// Start field
		$field = $this->modules->get('InputfieldDatetime');
		$fieldSet->add($this->populateInputField($field, array_merge(array(
			'name' => 'dateStart',
			'label' => $this->_('Start Date/Time'),
			'value' => (isset($dateStart)) ? $dateStart : '',
		), $datetimeFieldDefaults)));

		// End field
		$field = $this->modules->get('InputfieldDatetime');
		$fieldSet->add($this->populateInputField($field, array_merge(array(
			'name' => 'dateEnd',
			'label' => $this->_('End Date/Time'),
			'value' => (isset($dateEnd)) ? $dateEnd : '',
		), $datetimeFieldDefaults)));

		$form->add($fieldSet);

		// If we're editing:
		if ($editingId > 0) {
			// Get and ddd info markup
			$field = $this->modules->get('InputfieldMarkup');
			$userCreated = $this->users->get($userCreated);
			$userUpdated = $this->users->get($userUpdated);
			$userUrl = wire('config')->urls->admin . 'access/users/edit/?id=';
			$relativeTimes = array(
				'created' => wireRelativeTimeStr($createdAt),
				'updated' => wireRelativeTimeStr($updatedAt),
			);
			$form->add($this->populateInputField($field, array(
				'id' => 'info',
				'label' => $this->_('Info'),
				'value' => $this->blueprint('entity-info', array(
					'user-created-name' => $userCreated->name,
					'user-updated-name' => $userUpdated->name,
					'user-created-url' => $userUrl . $userCreated->id,
					'user-updated-url' => $userUrl . $userUpdated->id,
					'created-at' => $createdAt,
					'created-at-relative' => $relativeTimes['created'],
					'updated-at' => $updatedAt,
					'updated-at-relative' => $relativeTimes['updated'],
				)),
			)));

			// Add Delete button
			$field = $this->modules->get('InputfieldCheckbox');
			$form->add($this->populateInputField($field, array(
				'name' => 'delete',
				'label' => $this->_('Delete'),
				'icon' => 'times-circle',
				'description' => $this->_("If you'd like to delete this jumplink, check the box below."),
				'label2' => $this->_('Delete this jumplink'),
				'collapsed' => Inputfield::collapsedYes
			)));
		}

		// Save/Update button
		$field = $this->modules->get('InputfieldButton');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'saveJumplink',
			'value' => ($editingId) ? $this->_('Update Jumplink') : $this->_('Save Jumplink'),
			'icon' => 'save',
			'type' => 'submit',
		))->addClass('head_button_clone'));

		$this->config->js('pjEntity', true);

		// Return the rendered page
		return $form->render() . $this->helpLinks('Working-with-Jumplinks');
	}

	protected function commitJumplink($input, $hits = 0, $updating = false, $id = 0) {

		// If the Destination Path's URI matches that of a page, use a page ID instead
		if (false === strpos($input->destinationUriUrl, '{') && false === strpos($input->destinationUriUrl, '}')) {
			if (($page = $this->pages->get('name=' . trim($input->destinationUriUrl, '/'))) && $page->id) {
				$input->destinationUriUrl = "page:{$page->id}";
			}
		}

		// Escape Source and Destination (Sanitised) Paths
		$source = ltrim($this->db->escape_string($input->sourcePath), '/');
		$destination = ltrim($this->db->escape_string($this->sanitizer->url($input->destinationUriUrl)), '/');

		// Prepare dates (times) for database entry
		$start = (!isset($input->dateStart) || empty($input->dateStart)) ? 'null' : date('Y-m-d H:i:s', strtotime(str_replace('-', '/', $input->dateStart)));
		$end = (!isset($input->dateEnd) || empty($input->dateEnd)) ? 'null' : date('Y-m-d H:i:s', strtotime(str_replace('-', '/', $input->dateEnd)));

		// Set the user creating/updating
		if (!$updating) {
			$userCreated = $this->user->id;
		}
		$userUpdated = $this->user->id;

		// Insert/Update

		$dataBind = array(
			'source' => $source,
			'destination' => $destination,
			'date_start' => $start,
			'date_end' => $end,
			'user_updated' => $userUpdated,
		);

		if ($updating) {
			$query = $this->database->prepare($this->sql->entityUpdate);
			$dataBind['id'] = $id;
		} else {
			$query = $this->database->prepare($this->sql->entityInsert);
			$dataBind['hits'] = $hits;
			$dataBind['user_created'] = $userCreated;
		}
		$query->execute($dataBind);
	}

	/**
	 * API method to add a new jumplink
	 * @param String $source
	 * @param String $destination
	 * @param String $start
	 * @param String $end
	 */
	public function add($source, $destination, $start = '', $end = '') {

		$this->commitJumplink((object) array(
			'sourcePath' => $source,
			'destinationUriUrl' => $destination,
			'dateStart' => $start,
			'dateEnd' => $end,
		));
	}

	/**
	 * Admin Route: Commit new jumplink or update existing
	 */
	public function ___executeCommit() {

		// Just to be on the safe side...
		if ($this->input->post->id == null) {
			$this->session->redirect("../");
		}

		$input = $this->input->post;

		// Set the ID and check if we're updating
		$id = (int) $input->id;
		$isUpdating = ($id !== 0);

		// If we're updating, check if we should delete
		if ($isUpdating && $input->delete) {
			$query = $this->database->prepare($this->sql->entityDropById);
			$query->execute(array(
				'id' => $id
			));
			$this->message($this->_('Jumplink deleted.'));
			$this->session->redirect("../");
		}

		// Otherwise, continue to commit jumplink to DB
		$this->commitJumplink($input, 0, $isUpdating, $id);

		$this->message($this->_("Jumplink saved."));

		$this->session->redirect("../");
	}

	/**
	 * Admin Page: Install/Uninstall Mapping Collections
	 * @return string
	 */
	public function ___executeMappingCollection() {

		$this->injectAssets();

		$this->setFuel('processHeadline', $this->_('Install New Mapping Collection'));

		// Get the ID if we're editing
		$editingId = (isset($this->input->get->id)) ? $this->input->get->id : 0;

		if ($editingId) {
			// Fetch the details and list vars
			$query = $this->database->prepare($this->sql->mappingCollectionsSelectSingle);
			$query->execute(array(
				'id' => $editingId
			));
			list($id, $collectionName, $collectionData, $userCreated, $userUpdated, $updatedAt, $createdAt) = $query->fetch();

			$this->setFuel('processHeadline', $this->_("Editing Mapping Collection: $collectionName"));
		}

		// Prep the form
		$form = $this->modules->get('InputfieldForm');
		$form->id = 'pjInputForm';
		$form->method = 'POST';
		$form->action = '../commitmappingcollection/';

		// ID field
		$field = $this->modules->get('InputfieldHidden');
		$form->add($this->populateInputField($field, array(
			'name' => 'id',
			'value' => $editingId,
		)));

		// Mapping Name field
		$field = $this->modules->get('InputfieldText');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'collectionName',
			'label' => $this->_('Name'),
			'notes' => $this->_('Only use alpha characters (a-z). Name will be sanitised upon submission. This name is the identifier to be used in mapping wildcards.'),
			'required' => 1,
			'collapsed' => Inputfield::collapsedNever,
			'value' => isset($collectionName) ? $collectionName : '',
		)));

		// Mapping Data field
		$field = $this->modules->get('InputfieldTextarea');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'collectionData',
			'label' => $this->_('Mapping Data'),
			'description' => sprintf($this->_('Enter each mapping for this collection, one per line, in the following format: key=value. You will more than likely make use of this feature if you are mapping IDs to URL-friendly names. To learn more about how this feature works, please [read through the documentation](%s).'), $this->helpLinks("Mapping-Collections", true)),
			'notes' => sprintf($this->_("To make things easier, you'll probably want to export your data from your old platform/framework in this format.\n**Note:** All **values** will be cleaned according to the 'Wildcard Cleaning' setting in the [module's configuration](%s)."), $this->getModuleConfigUri()),
			'required' => 1,
			'rows' => 10,
			'collapsed' => Inputfield::collapsedNever,
			'value' => isset($collectionData) ? $collectionData : '',
		)));

		// If we're editing:
		if ($editingId > 0) {
			// Get and ddd info markup
			$field = $this->modules->get('InputfieldMarkup');
			$userCreated = $this->users->get($userCreated);
			$userUpdated = $this->users->get($userUpdated);
			$userUrl = wire('config')->urls->admin . 'access/users/edit/?id=';
			$relativeTimes = array(
				'created' => wireRelativeTimeStr($createdAt),
				'updated' => wireRelativeTimeStr($updatedAt),
			);
			$form->add($this->populateInputField($field, array(
				'id' => 'info',
				'label' => $this->_('Info'),
				'value' => $this->blueprint('entity-info', array(
					'user-created-name' => $userCreated->name,
					'user-updated-name' => $userUpdated->name,
					'user-created-url' => $userUrl . $userCreated->id,
					'user-updated-url' => $userUrl . $userUpdated->id,
					'created-at' => $createdAt,
					'created-at-relative' => $relativeTimes['created'],
					'updated-at' => $updatedAt,
					'updated-at-relative' => $relativeTimes['updated'],
				)),
			)));

			// Add Uninstall button
			$field = $this->modules->get('InputfieldCheckbox');
			$form->add($this->populateInputField($field, array(
				'name+id' => 'uninstallCollection',
				'label' => $this->_('Uninstall'),
				'icon' => 'times-circle',
				'description' => $this->_("If you'd like to uninstall this collection, check the box below."),
				'label2' => $this->_('Uninstall this collection'),
				'collapsed' => Inputfield::collapsedYes,
			)));
		}

		// Install/Update & Return button
		$field = $this->modules->get('InputfieldButton');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'installMappingCollection',
			'value' => ($editingId) ? $this->_('Update & Return') : $this->_('Install & Return'),
			'icon' => 'save',
			'type' => 'submit',
		)));

		$this->config->js('pjCollection', true);

		// Return the rendered page
		return $form->render() . $this->helpLinks('Mapping-Collections');
	}

	/**
	 * Commit a new mapping collection
	 * @param  String $collectionName
	 * @param  Array  $data
	 * @param  int    $id
	 */
	protected function commitMappingCollection($collectionName, $collectionData, $id = 0) {

		// Clean up name (alphas only)
		$collectionName = preg_replace('~[^a-z]~', '', strtolower($collectionName));

		// Fetch, trim, and explode the data for cleaning
		$mappings = explode("\n", trim($collectionData));

		$compiledMappings = array();

		// Split up the key/value pairs and clean
		foreach ($mappings as $mapping) {
			$mapping = explode('=', $mapping);

			$wildcardCleaning = $this->{self::wildcardCleaning};
			if ($wildcardCleaning === 'fullClean' || $wildcardCleaning === 'semiClean') {
				$mapping[1] = $this->cleanWildcard($mapping[1], ($wildcardCleaning === 'fullClean') ? false : true);
			}

			$compiledMappings[trim($mapping[0])] = $mapping[1];
		}

		$dbInput = '';

		foreach ($compiledMappings as $key => $value) {
			$dbInput .= "$key=$value\n";
		}

		$dbInput = trim($dbInput);

		$updating = ($id > 0);

		// Set the user creating/updating
		if (!$updating) {
			$userCreated = $this->user->id;
		}
		$userUpdated = $this->user->id;

		$dataBind = array(
			'collection' => $collectionName,
			'mappings' => $dbInput,
			'user_updated' => $userUpdated,
		);

		if ($updating) {
			$query = $this->database->prepare($this->sql->mappingCollectionsUpdate);
			$dataBind['id'] = $id;
		} else {
			$query = $this->database->prepare($this->sql->mappingCollectionsInsert);
			$dataBind['user_created'] = $userCreated;
		}
		$query->execute($dataBind);
	}

	/**
	 * API call to create a new collection, or add to an existing one
	 * @param String $name
	 * @param Array $data
	 */
	public function collection($name, $data) {

		$collectionData = "";
		$id = 0;

		// Check if the collection already exists
		// and grab its data if it does
		$collections = $this->database->prepare($this->sql->mappingCollectionsSelectSingleFromName);
		$collections->execute(array(
			'collection' => $name
		));
		if (count($collections) !== 0) {
			while ($collection = $collections->fetch(PDO::FETCH_OBJ)) {
				$id = (int) $collection->id;
				$collectionData = $collection->collection_mappings . "\n";
			}
		}

		// Gather the data from the array
		foreach ($data as $key => $value) {
			$collectionData .= "{$key}={$value}" . "\n";
		}

		// And send it off!
		$this->commitMappingCollection($name, trim($collectionData, "\n"), $id);
	}

	/**
	 * Admin Route: Commit new mapping collection or update existing
	 */
	public function ___executeCommitMappingCollection() {

		// Just to be on the safe side...
		if ($this->input->post->id == null) {
			$this->session->redirect("../");
		}

		$input = $this->input->post;

		// Set the ID and check if we're updating
		$id = (int) $input->id;
		$isUpdating = ($id > 0);

		// If we're updating, check if we should uninstall
		if ($isUpdating && $input->uninstallCollection) {
			$this->database->prepare($this->sql->mappingCollectionsDropById)->execute(array(
				'id' => $id
			));
			$this->message($this->_('Collection uninstalled.'));
			$this->session->redirect("../");
		}

		$this->commitMappingCollection($input->collectionName, $input->collectionData, $id);

		$this->message(sprintf($this->_("Mapping Collection '%s' saved."), $collectionName));

		$this->session->redirect("../");
	}

	/**
	 * Admin Page: Backup form
	 * @return string
	 */
	public function ___executeImport() {

		$this->injectAssets();

		$this->setFuel('processHeadline', $this->_('Import Jumplinks'));

		// Prep the form
		$form = $this->modules->get('InputfieldForm');
		$form->id = 'pjInputForm';
		$form->method = 'POST';
		$form->action = '../doimport/';

		$importType = $this->input->get->type;
		if (is_null($importType)) {
			$importType = 'csv';
		}

		switch ($importType) {
			case 'redirects':

				$this->config->js('pjImportRedirectsModule', true);

				if (!$this->modules->isInstalled('ProcessRedirects')) {
					$this->session->redirect('../');
				}

				if (!$this->redirectsImported) {
					// Information
					$field = $this->modules->get('InputfieldMarkup');
					$form->add($this->populateInputField($field, array(
						'label' => $this->_('Import from the Redirects module'),
						'value' => $this->_("You have the Redirects module installed. As such, you can migrate your existing redirects from the module (below) to Jumplinks. If there are any redirects you wish to exclude, simply uncheck the box in the first column"),
					)));
				}

				// Redirects
				$jumplinksMarkup = $this->modules->get('InputfieldMarkup');

				if ($this->redirectsImported) {
					$jumplinksMarkup->label = $this->_('Redirects already imported');
					$jumplinksMarkup->value = $this->_("All your redirects from ProcessRedirects have already been imported. You can safely uninstall ProcessRedirects.");
				} else {
					$jumplinksTable = $this->modules->get('MarkupAdminDataTable');
					$jumplinksTable->setClass('old-redirects');
					$jumplinksTable->setEncodeEntities(false);
					$jumplinksTable->setSortable(false);
					$jumplinksTable->headerRow(array($this->_('Import'), $this->_('Redirect From'), $this->_('Redirect To'), $this->_('Hits')));

					$jumplinks = $this->db->query("SELECT * FROM processredirects ORDER BY redirect_from");

					while ($jumplink = $jumplinks->fetch_object()) {

						$jumplinksTable->row(array(
							"<input type=\"checkbox\" name=\"importArray[]\" checked value=\"{$jumplink->id}\">",
							$jumplink->redirect_from,
							$jumplink->redirect_to,
							$jumplink->counter,
						));

					}

					$jumplinksMarkup->label = $this->_('Available Redirects');
					$jumplinksMarkup->value = $jumplinksTable->render();
				}

				$form->add($jumplinksMarkup);

				break;

			default:	// type = csv

				$this->config->js('pjImportCSVData', true);

				// Information
				$field = $this->modules->get('InputfieldTextarea');
				$form->add($this->populateInputField($field, array(
					'name+id' => 'csvData',
					'label' => $this->_('Import from CSV'),
					'description' => sprintf($this->_("Paste in your old redirects below, where each one is on its own line. You may use any standard delimeter you like (comma, colon, semi-colon, period, pipe, or tab), so long as it is consistent throughout. Any URI/URL that contains the delimter must be wrapped in double quotes.\n\n**Columns:** Source, Destination, Time Start, Time End. The last two columns are optional - when used, they should contain any valid date/time string. However, if they are used in one line, then all other lines should have blank entries for these columns.\n\nFor examples, [see the documentation](%s)."), $this->helpLinks("Importing#importing-from-{$importType}", true)),
					'notes' => $this->_("**Conversion Notes:**\n1. Any encoded ampersands (**&amp;amp;**) will be converted to **&amp;**.\n2. If the source or destination of a redirect contains leading slashes, they will be stripped."),
					'rows' => 15,
				)));

				// Headings
				$field = $this->modules->get('InputfieldCheckbox');
				$form->add($this->populateInputField($field, array(
					'name+id' => 'csvHeadings',
					'label' => $this->_('My CSV data contains headings'),
				)));

				break;
		}

		// Type of import
		$field = $this->modules->get('InputfieldHidden');
		$form->add($this->populateInputField($field, array(
			'name' => 'importType',
			'value' => $importType,
		)));

		// Import data/redirects button
		$field = $this->modules->get('InputfieldButton');
		if ($importType === 'redirects' && !$this->redirectsImported) {
			$form->add($this->populateInputField($field, array(
				'name+id' => 'doImport',
				'value' => 'Import these Redirects',
				'icon' => 'arrow-right',
				'type' => 'submit',
			))->addClass('head_button_clone'));
		} else if ($importType !== 'redirects') {
			$form->add($this->populateInputField($field, array(
				'name+id' => 'doImport',
				'value' => 'Import Data',
				'icon' => 'cloud-upload',
				'type' => 'submit',
			))->addClass('head_button_clone'));
		}

		// Rename import type for docs
		if ($importType === 'redirects') {
			$importType = 'processredirects';
		}

		$this->config->js('pjImport', true);

		return $form->render() . $this->helpLinks("Importing#importing-from-{$importType}");
	}

	/**
	 * Admin Route: Do an import based on data sent.
	 */
	public function ___executeDoImport() {

		// Just to be on the safe side...
		if ($this->input->post->importType == null) {
			$this->session->redirect("../");
		}

		// Get the type of import ...
		$importType = $this->input->post->importType;

		// ... and go!
		switch ($importType) {
			case 'csv':

				// Prepare the parser
				$csv = new ParseCSV();
				$csv->heading = $this->input->post->csvHeadings;
				$csv->auto($this->input->post->csvData);

				$cols = array('source', 'destination', 'date_start', 'date_end');

				// Loop through each row and column to cleanse
				// data and insert into table
				foreach ($csv->data as $key => $row) {
					$jumplink = array();
					$col = 0;
					foreach ($row as $value) {
						++$col;
						if ($col >= 4) {
							continue;
						}

						$value = ltrim($value, '/');

						// check which col we're working with
						// and cleanse accordingly
						switch ($col) {
							case 1: // source
								$value = str_replace('&amp;', '&', $value);
								break;
							case 2: // destination
								$value = str_replace('&amp;', '&', $this->sanitizer->url($value));
								break;
							case 3: // time start
							case 4: // time end
								$value = empty($value) ? 'null' : "'" . date('Y-m-d H:i:s', strtotime(str_replace('-', '/', $value))) . "'";
								break;
						}

						$jumplink[$cols[$col-1]] = $this->db->escape_string($value);

					}

					if ($col === 2) {
						$jumplink[$cols[2]] = 'null';
						$jumplink[$cols[3]] = 'null';
					}

					$this->database->prepare($this->sql->entityInsert)->execute(array(
						'source' => $jumplink['source'],
						'destination' => $jumplink['destination'],
						'date_start' => $jumplink['date_start'],
						'date_end' => $jumplink['date_end'],
						'hits' => 0,
						'user_updated' => $this->user->id,
						'user_created' => $this->user->id,
					));
				}

				$this->message('Redirects imported.');
				$this->session->redirect('../');

				break;

			case 'redirects':

				// Fetch the importArray - make sure all values are integers.
				$redirectsArray = implode(',', array_map('intval', $this->input->post->importArray));

				// Now fetch the redirects
				$query = $this->database->prepare("SELECT * FROM processredirects WHERE id IN (:redirects_array)");
				$query->execute(array(
					'redirects_array' => $redirectsArray
				));

				// And import them
				while ($redirect = $query->fetch(PDO::FETCH_OBJ)) {
					$jumplink = (object) array(
						'sourcePath' => $redirect->redirect_from,
						'destinationUriUrl' => preg_replace("~\^(\d+)$~i", "page:\\1", $redirect->redirect_to)
					);
					$this->commitJumplink($jumplink, $redirect->counter);
				}

				// Don't allow another import (we're importing for a reason - to migrate over to one module)
				$configData = $this->modules->getModuleConfigData($this);
				$configData['redirectsImported'] = true;
				$this->modules->saveModuleConfigData($this, $configData);

				$this->message('Redirects imported. You can now safely uninstall ProcessRedirects.');
				$this->session->redirect('../');

				break;

			default:
				$this->session->redirect('../');
		}

	}

	/**
	 * Install the module
	 */
	public function ___install() {

		// Install tables (their schemas may not remain the same as updateDatabaseSchemas() may change them)
		foreach (array('main', 'mc') as $schema) {
			$this->db->query($this->blueprint("schema-create-{$schema}"));
		}

		parent::___install();
	}

	/**
	 * Uninstall the module
	 */
	public function ___uninstall() {

		// Uninstall tables
		$this->db->query($this->blueprint('schema-drop'));
		parent::___uninstall();
	}

	/**
	 * Dump and die
	 * @param  Mixed $mixed Anything
	 */
	protected function dd($mixed, $die = true) {

		header('Content-Type: text/plain');
		var_dump($mixed); $die && die;
	}

}
