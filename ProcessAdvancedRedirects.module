<?php

/**
 * ProcessAdvancedRedirects - a ProcessWire Module by Mike Anthony
 * Manage permanent and temporary redirects. Supports wildcards.
 *
 * Intended for: ProcessWire 2.6-dev
 * Developed in: ProcessWire 2.5.13
 *
 * Copyright (c) 2015, Mike Anthony. All Rights Reserved.
 * Licence: MIT License - http://mikeanthony.mit-license.org/
 *
 * http://pw.foundrybusiness.co.za/advanced-redirects
 *
 */

require_once __DIR__ . '/AdvancedRedirects.php';

use ProcessAdvancedRedirectsConfig as Config;

class ProcessAdvancedRedirects extends AdvancedRedirects {

	/**
	 * Admin Page: Module Root
	 * @return string
	 */
	public function ___execute() {
		$redirects = $this->db->query($this->sql->entitySelectAll);
		$this->setFuel('processHeadline', $this->moduleInfo['title']);

		// If we don't have any redirects defined, then we should start be creating one
		if ($redirects->num_rows == 0) {
			$this->session->redirect("{$this->formPath}?first");
		}

		$tabContainer = new InputfieldWrapper();

		$redirectsTab = new InputfieldWrapper();
		$redirectsTab->attr('title', 'Redirects');

		$redirectsTable = $this->modules->get('MarkupAdminDataTable');
		$redirectsTable->setEncodeEntities(false);
		$redirectsTable->setClass('advanced-redirects redirects');
		$redirectsTable->headerRow(array($this->_('Source'), $this->_('Destination'), $this->_('Start'), $this->_('End')));
		$registerRedirectButtonLabel = ($redirects->num_rows === 1) ? $this->_('Register Another Redirect') : $this->_('Register New Redirect');

		$head = $this->_n('You have one redirect registered.', 'Your redirects are listed below.', $redirects->num_rows);
		$pronoun = $this->_n('it', 'one', $redirects->num_rows);
		$more = sprintf($this->_("To edit/delete %s, simply click on its Source. To add another, click on '%s' at the bottom."), $pronoun, $registerRedirectButtonLabel);
		$description = $this->blueprint('manage-description', array(
			'head' => $head,
			'more' => $more,
			'class' => "count-{$redirects->num_rows}",
		));

		while ($redirect = $redirects->fetch_object()) {
			$redirect->source = htmlentities($redirect->source);
			$redirect->destination = $this->compileDestinationUrl($redirect->destination, true);
			$relativeStartTime = str_replace('Never', '', wireRelativeTimeStr($redirect->date_start, true));
			$relativeEndTime = str_replace('Never', '', wireRelativeTimeStr($redirect->date_end, true));

			$relativeStartTime = ($relativeStartTime === '-')
			? $relativeStartTime
			: "<abbr title=\"{$redirect->date_start}\">{$relativeStartTime}</abbr>";
			$relativeEndTime = ($relativeEndTime === '-')
			? $relativeEndTime
			: "<abbr title=\"{$redirect->date_end}\">{$relativeEndTime}</abbr>";

			$redirectsTable->row(array(
				$this->truncate($redirect->source) => "entity/?id={$redirect->id}",
				$redirect->destination,
				$relativeStartTime,
				$relativeEndTime,
			));
		}

		$wordLinks = ($redirects->num_rows === 1) ? 'redirect' : 'redirects';
		$redirectsTable->footerRow(array("{$redirects->num_rows} {$wordLinks}", '', '', ''));

		$redirects->close();

		$registerRedirectButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
			'id' => 'registerRedirect',
			'href' => 'entity/',
			'value' => $registerRedirectButtonLabel,
			'icon' => 'plus-circle',
		))->addClass('head_button_clone');

		$moduleConfigLinkButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
			'id' => 'moduleConfigLink',
			'href' => $this->getModuleConfigUri(),
			'value' => $this->_('Configuration'),
			'icon' => 'cog',
		))->addClass('ui-priority-secondary ui-button-float-right');

		$buttons = $registerRedirectButton->render() .
		$moduleConfigLinkButton->render();

		$redirectsTableContainer = $this->modules->get('InputfieldMarkup');
		$redirectsTableContainer->value = $description . $redirectsTable->render() . $buttons;

		$redirectsTab->append($redirectsTableContainer);

		$mappingCollectionsTab = new InputfieldWrapper();
		$mappingCollectionsTab->attr('title', 'Mapping Collections');
		$mappingCollectionsTab->id = 'mappingCollections';

		$mappingCollections = $this->db->query($this->sql->mappingCollectionsSelectAll);

		$mappingCollectionsTable = $this->modules->get('MarkupAdminDataTable');
		$mappingCollectionsTable->setEncodeEntities(false);
		$mappingCollectionsTable->setClass('advanced-redirects mapping-collections');
		$mappingCollectionsTable->setSortable(false);
		$mappingCollectionsTable->headerRow(array($this->_('Collection Name'), $this->_('Mappings'), $this->_('Created'), $this->_('Last Modified')));

		$installMappingCollectionButtonLabel = ($mappingCollections->num_rows === 1) ? $this->_('Install Another Mapping Collection') : $this->_('Install New Mapping Collection');

		if ($mappingCollections->num_rows === 0) {
			$pronoun = 'one';
			$head = $this->_("You don't have any collections installed.");
		} else {
			$head = $this->_n('You have one collection installed.', 'Your collections are listed below.', $mappingCollections->num_rows);
			$pronoun = $this->_n('it', 'one', $mappingCollections->num_rows);
		}

		$more = ($mappingCollections->num_rows === 0) ? '' : sprintf($this->_("To edit/delete %s, simply click on its name. To add another, click on '%s' at the bottom."), $pronoun, $installMappingCollectionButtonLabel);
		$description = $this->blueprint('manage-description', array(
			'head' => $head,
			'more' => $more,
			'class' => "count-{$mappingCollections->num_rows}",
		));

		while ($mappingCollection = $mappingCollections->fetch_object()) {
			$userCreated = $this->users->get($mappingCollection->user_created)->name;
			$userUpdated = $this->users->get($mappingCollection->user_updated)->name;

			$created = wireRelativeTimeStr($mappingCollection->created_at) . " by {$userCreated}";
			$updated = wireRelativeTimeStr($mappingCollection->updated_at) . " by {$userUpdated}";

			if ($mappingCollection->created_at === $mappingCollection->updated_at) {
				$updated = '';
			}

			$mappingCollectionsTable->row(array(
				$mappingCollection->collection_name => "mapping-collection/?id={$mappingCollection->id}",
				count(explode("\n", trim($mappingCollection->collection_mappings))),
				$created,
				$updated,
			));
		}

		$installMappingCollectionButton = $this->populateInputField($this->modules->get('InputfieldButton'), array(
			'id' => 'installMappingCollection',
			'href' => "mapping-collection/",
			'value' => $installMappingCollectionButtonLabel,
			'icon' => 'plus-circle',
		));

		$buttons = $installMappingCollectionButton->render();

		$mappingCollectionsTableContainer = $this->modules->get('InputfieldMarkup');
		$mappingCollectionsTableContainer->value = $description . $mappingCollectionsTable->render() . $buttons;

		$mappingCollectionsTab->append($mappingCollectionsTableContainer);

		// $logTab = new InputfieldWrapper();
		// $logTab->attr('title', 'Log');
		// $logTab->id = 'log';

		// $logTableContainer = $this->modules->get('InputfieldMarkup');
		// $logTableContainer->value = 'Log not implemented yet.';

		// $logTab->append($logTableContainer);

		$tabContainer
			->append($redirectsTab)
			->append($mappingCollectionsTab);
		//->append($logTab);

		$this->config->js("parAdmin", true);

		// Unfortunately, we have to wrap it in a form to prevent spacing underneath
		// the tabs. This goes hand in hand with a rule in the stylesheet
		return "<form id=\"parTabs\">{$tabContainer->render()}</form>{$this->helpLink}";
	}

	/**
	 * Admin Page: Add/Edit Entity (Redirect)
	 * @return string
	 */
	public function ___executeEntity() {
		$this->setFuel('processHeadline', $this->_('Register New Redirect'));

		// Get the ID if we're editing
		$editingId = (isset($this->input->get->id)) ? $this->input->get->id : 0;

		if ($editingId) {
			// Fetch the details and list vars
			$result = $this->db->query(sprintf($this->sql->entitySelectSingle, $editingId));
			list($id, $sourcePath, $destinationUriUrl,
				$userCreated, $userUpdated, $dateStart, $dateEnd,
				$createdAt, $updatedAt) = $result->fetch_array();

			$this->setFuel('processHeadline', $this->_('Editing Redirect'));

			// Format dates (times)
			$dateStart = ($dateStart != null) ? date('Y-m-d h:m A', strtotime($dateStart)) : null;
			$dateEnd = ($dateEnd != null) ? date('Y-m-d h:m A', strtotime($dateEnd)) : null;
		}

		// Check if this is or first redirect
		$message = '';
		if (isset($this->input->get->first)) {
			$message = $this->_("You don't have any redirects registered. Let's create a new one now.");
			$message = "<p class=\"description parInfo\">{$message}</p>";
			$this->setFuel('processHeadline', $this->_('Register First Redirect'));
		}

		// Prep the form
		$form = $this->modules->get('InputfieldForm');
		$form->id = 'parInputForm';
		$form->method = 'POST';
		$form->action = '../commit/';

		// ID field
		$field = $this->modules->get('InputfieldHidden');
		$form->add($this->populateInputField($field, array(
			'name' => 'id',
			'value' => $editingId,
		)));

		// Source Path field
		$field = $this->modules->get('InputfieldText');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'sourcePath',
			'label' => $this->_('Source'),
			'description' => $this->_("Enter a path that's relative to the root of this installation, without the leading slash."),
			'notes' => sprintf($this->_("**Examples:** page.html, [{page:segment}](%1\$s/wildcards).html, page.php?name={page:segment}, [page.php?id={id}](%1\$s/mapping-collections)"), $this->moduleInfo['href']),
			'required' => 1,
			'collapsed' => Inputfield::collapsedNever,
			'value' => isset($sourcePath) ? $sourcePath : '',
		)));

		// Destination fields
		$destinationPageField = $this->modules->get('InputfieldPageListSelect');
		$destinationPathField = $this->modules->get('InputfieldURL');

		// Check if the current destination is a page
		if (isset($destinationUriUrl) && $page = $this->pages->get((int) str_replace('page:', '', $destinationUriUrl))) {
			$isPage = (bool) $page->id;
			if ($isPage) {
				$destinationPageField->value = $page->id;
				$destinationPathField->collapsed = Inputfield::collapsedYes;
			} else {
				$destinationPageField->collapsed = Inputfield::collapsedYes;
				$destinationPathField->collapsed = Inputfield::collapsedBlank;
			}
		} else {
			$destinationPathField->collapsed = Inputfield::collapsedBlank;
		}

		$form->add($this->populateInputField($destinationPageField, array(
			'name+id' => 'destinationPage',
			'label' => $this->_('Select a Page'),
			'notes' => $this->_("If you leave this out, be sure to enter a valid path below.\n**Note:** If you need to see the details of a page in another language, you'll need to [switch to that language first](../../../profile)."),
			'parent_id' => 0,
			'startLabel' => $this->_('Select Page'),
		)));

		// Destination Path field
		$form->add($this->populateInputField($destinationPathField, array(
			'name+id' => 'destinationUriUrl',
			'label' => $this->_('or enter a URI/URL'),
			'description' => $this->_('Enter a URI relative to the root of this installation, without the leading slash, or an absolute URL.'),
			'notes' => sprintf($this->_("**Examples:** path/, {path}/, http://domain.com/{path}, [product/{id|products}](%s/mapping-collections) .\n**Note:** If you select a page from the Page Selector above, its identifier will be added here."), $this->moduleInfo['href']),
			'required' => 1,
			'value' => isset($destinationUriUrl) ? $destinationUriUrl : '',
		)));

		// Timed Activation fieldset
		$fieldSet = $this->modules->get('InputfieldFieldset');
		$fieldSet->label = 'Timed Activation';
		$fieldSet->collapsed = Inputfield::collapsedYes;
		$fieldSet->description = $this->_("If you'd like this redirect to only function during a specific time-range, then select the start and end dates and times below.");
		$fieldSet->notes = $this->_("You don't have to specify both. If you only specify a start time , you're simply delaying activation. If you only specify an end time, then you're simply telling it when to stop.\nIf an End Date/Time is specified, a temporary redirect will be made (302 status code, as opposed to 301).");

		$datetimeFieldDefaults = array(
			'datepicker' => 1,
			'timeInputFormat' => 'h:m A',
			'yearRange' => '-0:+100',
			'collapsed' => Inputfield::collapsedNever,
			'columnWidth' => 50,
		);

		// Start field
		$field = $this->modules->get('InputfieldDatetime');
		$fieldSet->add($this->populateInputField($field, array_merge(array(
			'name' => 'dateStart',
			'label' => $this->_('Start Date/Time'),
			'value' => (isset($dateStart)) ? $dateStart : '',
		), $datetimeFieldDefaults)));

		// End field
		$field = $this->modules->get('InputfieldDatetime');
		$fieldSet->add($this->populateInputField($field, array_merge(array(
			'name' => 'dateEnd',
			'label' => $this->_('End Date/Time'),
			'value' => (isset($dateEnd)) ? $dateEnd : '',
		), $datetimeFieldDefaults)));

		$form->add($fieldSet);

		// If we're editing:
		if ($editingId > 0) {
			// Get and ddd info markup
			$field = $this->modules->get('InputfieldMarkup');
			$userCreated = $this->users->get($userCreated);
			$userUpdated = $this->users->get($userUpdated);
			$userUrl = wire('config')->urls->admin . 'access/users/edit/?id=';
			$relativeTimes = array(
				'created' => wireRelativeTimeStr($createdAt),
				'updated' => wireRelativeTimeStr($updatedAt),
			);
			$form->add($this->populateInputField($field, array(
				'id' => 'info',
				'label' => $this->_('Info'),
				'value' => $this->blueprint('entity-info', array(
					'user-created-name' => $userCreated->name,
					'user-updated-name' => $userUpdated->name,
					'user-created-url' => $userUrl . $userCreated->id,
					'user-updated-url' => $userUrl . $userUpdated->id,
					'created-at' => $createdAt,
					'created-at-relative' => $relativeTimes['created'],
					'updated-at' => $updatedAt,
					'updated-at-relative' => $relativeTimes['updated'],
				)),
			)));

			// Add Delete button
			$field = $this->modules->get('InputfieldCheckbox');
			$form->add($this->populateInputField($field, array(
				'name' => 'delete',
				'label' => $this->_('Delete'),
				'icon' => 'times-circle',
				'description' => $this->_("If you'd like to delete this redirect, check the box below."),
				'label2' => $this->_('Delete this redirect'),
				'collapsed' => Inputfield::collapsedYes,
				'showIf' => 'isPermanent=0',
			)));
		}

		// Save/Update button
		$field = $this->modules->get('InputfieldButton');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'saveRedirect',
			'value' => ($editingId) ? $this->_('Update & Return') : $this->_('Save & Return'),
			'icon' => 'save',
			'type' => 'submit',
		))->addClass('head_button_clone'));

		$this->config->js('parEntity', true);

		// Return the rendered page
		return $message . $form->render() . $this->helpLink;
	}

	/**
	 * Admin Route: Commit new redirect or update existing
	 */
	public function ___executeCommit() {
		// Just to be on the safe side...
		if ($this->input->post->id == null) {
			$this->session->redirect("../");
		}

		$input = $this->input->post;

		// Set the ID and check if we're updating
		$id = (int) $input->id;
		$isUpdating = ($id !== 0);

		// If we're updating, check if we should delete
		if ($isUpdating && $input->delete) {
			$this->db->query(sprintf($this->sql->entityDropById, $id));
			$this->message($this->_('Redirect deleted.'));
			$this->session->redirect("../");
		}

		// If the Destination Path's URI matches that of a page, use a page ID instead
		if (false === strpos($input->destinationUriUrl, '{') && false === strpos($input->destinationUriUrl, '}')) {
			if (($page = $this->pages->get('name=' . trim($input->destinationUriUrl, '/'))) && $page->id) {
				$input->destinationUriUrl = "page:{$page->id}";
			}
		}

		// Escape Source and Destination (Sanitised) Paths
		$source = ltrim($this->db->escape_string($input->sourcePath), '/');
		$destination = ltrim($this->db->escape_string($this->sanitizer->url($input->destinationUriUrl)), '/');

		// Prepare dates (times) for database entry
		$start = empty($input->dateStart) ? 'null' : "'" . date('Y-m-d H:i:s', strtotime(str_replace('-', '/', $input->dateStart))) . "'";
		$end = empty($input->dateEnd) ? 'null' : "'" . date('Y-m-d H:i:s', strtotime(str_replace('-', '/', $input->dateEnd))) . "'";

		// Set the user creating/updating
		if (!$isUpdating) {
			$userCreated = $this->user->id;
		}

		$userUpdated = $this->user->id;

		// Insert/Update
		$this->db->query(($isUpdating)
			? sprintf($this->sql->entityUpdate, $source, $destination, $start, $end, $userUpdated, $id)
			: sprintf($this->sql->entityInsert, $source, $destination, $start, $end, $userCreated, $userUpdated)
		);

		$this->message($this->_("Redirect saved."));

		$this->session->redirect("../");
	}

	/**
	 * Admin Page: Install/Uninstall Mapping Collections
	 * @return string
	 */
	public function ___executeMappingCollection() {
		$this->setFuel('processHeadline', $this->_('Install New Mapping Collection'));

		// Get the ID if we're editing
		$editingId = (isset($this->input->get->id)) ? $this->input->get->id : 0;

		if ($editingId) {
			// Fetch the details and list vars
			$result = $this->db->query(sprintf($this->sql->mappingCollectionsSelectSingle, $editingId));
			list($id, $collectionName, $collectionData, $userCreated, $userUpdated, $createdAt, $updatedAt) = $result->fetch_array();

			$this->setFuel('processHeadline', $this->_("Editing Mapping Collection: $collectionName"));
		}

		// Prep the form
		$form = $this->modules->get('InputfieldForm');
		$form->id = 'parInputForm';
		$form->method = 'POST';
		$form->action = '../commit-mapping-collection/';

		// ID field
		$field = $this->modules->get('InputfieldHidden');
		$form->add($this->populateInputField($field, array(
			'name' => 'id',
			'value' => $editingId,
		)));

		// Mapping Name field
		$field = $this->modules->get('InputfieldText');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'collectionName',
			'label' => $this->_('Name of Collection'),
			'notes' => $this->_('Only use alpha characters (a-z). Name will be sanitised upon submission. This name is the identifier to be used in mapping wildcards.'),
			'required' => 1,
			'collapsed' => Inputfield::collapsedNever,
			'value' => isset($collectionName) ? $collectionName : '',
		)));

		// Mapping Data field
		$field = $this->modules->get('InputfieldTextarea');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'collectionData',
			'label' => $this->_('Collection Data'),
			'description' => $this->_('Enter each mapping for this collection, one per line, in the following format: key=value. You will more than likely make use of this feature if you are mapping IDs to URL-friendly names. To learn more about how this feature works, please read through the documentation.'),
			'notes' => sprintf($this->_("To make things easier, you'll probably want to export your data from your old platform/framework in this format.\n**Note:** All **values** will be cleaned according to the 'Clean Paths' setting in the [module's configuration](%s)."), $this->getModuleConfigUri()),
			'required' => 1,
			'rows' => 10,
			'collapsed' => Inputfield::collapsedNever,
			'value' => isset($collectionData) ? $collectionData : '',
		)));

		// If we're editing:
		if ($editingId > 0) {
			// Get and ddd info markup
			$field = $this->modules->get('InputfieldMarkup');
			$userCreated = $this->users->get($userCreated);
			$userUpdated = $this->users->get($userUpdated);
			$userUrl = wire('config')->urls->admin . 'access/users/edit/?id=';
			$relativeTimes = array(
				'created' => wireRelativeTimeStr($createdAt),
				'updated' => wireRelativeTimeStr($updatedAt),
			);
			$form->add($this->populateInputField($field, array(
				'id' => 'info',
				'label' => $this->_('Info'),
				'value' => $this->blueprint('entity-info', array(
					'user-created-name' => $userCreated->name,
					'user-updated-name' => $userUpdated->name,
					'user-created-url' => $userUrl . $userCreated->id,
					'user-updated-url' => $userUrl . $userUpdated->id,
					'created-at' => $createdAt,
					'created-at-relative' => $relativeTimes['created'],
					'updated-at' => $updatedAt,
					'updated-at-relative' => $relativeTimes['updated'],
				)),
			)));

			// Add Uninstall button
			$field = $this->modules->get('InputfieldCheckbox');
			$form->add($this->populateInputField($field, array(
				'name+id' => 'uninstallCollection',
				'label' => $this->_('Uninstall'),
				'icon' => 'times-circle',
				'description' => $this->_("If you'd like to uninstall this collection, check the box below."),
				'label2' => $this->_('Uninstall this collection'),
				'collapsed' => Inputfield::collapsedYes,
			)));
		}

		// Install/Update & Return button
		$field = $this->modules->get('InputfieldButton');
		$form->add($this->populateInputField($field, array(
			'name+id' => 'installMappingCollection',
			'value' => ($editingId) ? $this->_('Update & Return') : $this->_('Install & Return'),
			'icon' => 'save',
			'type' => 'submit',
		)));

		$this->config->js('parCollection', true);

		// Return the rendered page
		return $form->render() . $this->helpLink;
	}

	/**
	 * Admin Route: Commit new mapping collection or update existing
	 */
	public function ___executeCommitMappingCollection() {
		// Just to be on the safe side...
		if ($this->input->post->id == null) {
			$this->session->redirect("../");
		}

		$input = $this->input->post;

		// Set the ID and check if we're updating
		$id = (int) $input->id;
		$isUpdating = ($id !== 0);

		// If we're updating, check if we should delete
		if ($isUpdating && $input->uninstallCollection) {
			$this->db->query(sprintf($this->sql->mappingCollectionsDropById, $id));
			$this->message($this->_('Collection uninstalled.'));
			$this->session->redirect("../");
		}

		// Clean up name (alphas only)
		$collectionName = preg_replace('~[^a-z]~', '', strtolower($input->collectionName));

		// Fetch, trim, and explode the data for cleaning
		$collectionMappings = $input->collectionData;
		$mappings = explode(PHP_EOL, trim($collectionMappings));

		$compiledMappings = array();

		// Split up the key/value pairs and clean
		foreach ($mappings as $mapping) {
			$mapping = explode('=', $mapping);

			$cleanPath = $this->{Config::CLEAN_PATH};
			if ($cleanPath === 'fullClean' || $cleanPath === 'semiClean') {
				$mapping[1] = $this->cleanPath($mapping[1], ($cleanPath === 'fullClean') ? false : true);
			}

			$compiledMappings[trim($mapping[0])] = $mapping[1];
		}

		$dbInput = '';

		foreach ($compiledMappings as $key => $value) {
			$dbInput .= "$key=$value\n";
		}

		$dbInput = trim($dbInput);

		//var_dump($dbInput);die;

		// Set the user creating/updating
		if (!$isUpdating) {
			$userCreated = $this->user->id;
		}
		$userUpdated = $this->user->id;

		// Insert/Update
		$this->db->query(($isUpdating)
			? sprintf($this->sql->mappingCollectionsUpdate, $collectionName, $dbInput, $userUpdated, $id)
			: sprintf($this->sql->mappingCollectionsInsert, $collectionName, $dbInput, $userCreated, $userUpdated)
		);

		$this->message(sprintf($this->_("Mapping Collection '%s' saved."), $collectionName));

		$this->session->redirect("../");
	}

	/**
	 * Install the module
	 */
	public function ___install() {
		// Install tables (their schemas may not remain the same as updateDatabaseSchemas() may change them)
		foreach (array('main', 'logs', 'mc') as $schema) {
			$this->db->query($this->blueprint("schema-create-{$schema}"));
		}

		parent::___install();
	}

	/**
	 * Uninstall the module
	 */
	public function ___uninstall() {
		// Uninstall tables
		$this->db->query($this->blueprint('schema-drop'));
		parent::___uninstall();
	}

}
